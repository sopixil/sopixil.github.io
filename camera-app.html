<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Camera Color Picker</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
  #container { position: relative; display: none; margin-top: 20px; }
  #preview { max-width: 100%; border: 1px solid #ccc; }
  #overlayCircle {
    position: absolute; 
    border: 3px solid red; 
    border-radius: 50%; 
    width: 40px; 
    height: 40px; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%);
    display: none;
    pointer-events: none;
  }
  #colorBox {
    width: 60px; 
    height: 60px; 
    margin: 20px auto 5px; 
    border: 1px solid #333; 
    display: none;
    border-radius: 6px;
  }
  #hexCode, #sherwinName {
    font-weight: bold; 
    margin: 4px 0; 
    display: none;
  }
  #editButton {
    background-color: #b8860b;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    cursor: pointer;
    display: none;
    font-weight: bold;
    margin-top: 10px;
  }
  #fileInput {
    display: none;
  }
  label[for="fileInput"] {
    display: inline-block;
    background: #007bff;
    color: white;
    padding: 14px 30px;
    border-radius: 50px;
    font-size: 16px;
    cursor: pointer;
    user-select: none;
    font-weight: bold;
  }
</style>
</head>
<body>

<label for="fileInput">Take Photo</label>
<input type="file" accept="image/*" capture="environment" id="fileInput" />

<div id="container">
  <img id="preview" alt="Captured photo" />
  <div id="overlayCircle"></div>
</div>

<div id="colorBox"></div>
<div id="hexCode"></div>
<div id="sherwinName"></div>
<button id="editButton">Edit Colour</button>

<script>
function deg2rad(deg) { return (deg * Math.PI) / 180; }
function rad2deg(rad) { return (rad * 180) / Math.PI; }
function rgbToLab(r, g, b) {
  let [x, y, z] = [r, g, b].map(v => {
    v /= 255;
    return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  x = (x * 0.4124 + y * 0.3576 + z * 0.1805) / 0.95047;
  y = (x * 0.2126 + y * 0.7152 + z * 0.0722) / 1.00000;
  z = (x * 0.0193 + y * 0.1192 + z * 0.9505) / 1.08883;
  const fx = x > 0.008856 ? Math.cbrt(x) : (7.787 * x) + 16 / 116;
  const fy = y > 0.008856 ? Math.cbrt(y) : (7.787 * y) + 16 / 116;
  const fz = z > 0.008856 ? Math.cbrt(z) : (7.787 * z) + 16 / 116;
  return { L: (116 * fy) - 16, a: 500 * (fx - fy), b: 200 * (fy - fz) };
}
function ciede2000(lab1, lab2) {
  const {L: L1, a: a1, b: b1} = lab1;
  const {L: L2, a: a2, b: b2} = lab2;
  const avgLp = (L1 + L2) / 2;
  const C1 = Math.sqrt(a1 * a1 + b1 * b1);
  const C2 = Math.sqrt(a2 * a2 + b2 * b2);
  const avgC = (C1 + C2) / 2;
  const G = 0.5 * (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7))));
  const a1p = a1 * (1 + G);
  const a2p = a2 * (1 + G);
  const C1p = Math.sqrt(a1p * a1p + b1 * b1);
  const C2p = Math.sqrt(a2p * a2p + b2 * b2);
  const avgCp = (C1p + C2p) / 2;
  const h1p = Math.atan2(b1, a1p) >= 0 ? Math.atan2(b1, a1p) : Math.atan2(b1, a1p) + 2 * Math.PI;
  const h2p = Math.atan2(b2, a2p) >= 0 ? Math.atan2(b2, a2p) : Math.atan2(b2, a2p) + 2 * Math.PI;
  const avghp = Math.abs(h1p - h2p) > Math.PI ? (h1p + h2p + 2 * Math.PI) / 2 : (h1p + h2p) / 2;
  const T = 1
    - 0.17 * Math.cos(avghp - deg2rad(30))
    + 0.24 * Math.cos(2 * avghp)
    + 0.32 * Math.cos(3 * avghp + deg2rad(6))
    - 0.20 * Math.cos(4 * avghp - deg2rad(63));
  let deltahp = h2p - h1p;
  if (Math.abs(deltahp) > Math.PI) deltahp += (deltahp > 0) ? -2 * Math.PI : 2 * Math.PI;
  const deltaLp = L2 - L1;
  const deltaCp = C2p - C1p;
  const deltaHp = 2 * Math.sqrt(C1p * C2p) * Math.sin(deltahp / 2);
  const SL = 1 + ((0.015 * Math.pow(avgLp - 50, 2)) / Math.sqrt(20 + Math.pow(avgLp - 50, 2)));
  const SC = 1 + 0.045 * avgCp;
  const SH = 1 + 0.015 * avgCp * T;
  const deltaRo = 30 * Math.exp(-((rad2deg(avghp) - 275) / 25) ** 2);
  const RC = 2 * Math.sqrt(Math.pow(avgCp, 7) / (Math.pow(avgCp, 7) + Math.pow(25, 7)));
  const RT = -RC * Math.sin(2 * deg2rad(deltaRo));
  return Math.sqrt(
    Math.pow(deltaLp / SL, 2) +
    Math.pow(deltaCp / SC, 2) +
    Math.pow(deltaHp / SH, 2) +
    RT * (deltaCp / SC) * (deltaHp / SH)
  );
}
function loadSherwinColors(text) {
  const colorList = [];
  const lines = text.trim().split(/\r?\n/);
  lines.forEach(line => {
    const parts = line.split(" ");
    const code = parts[0];
    const r = parseInt(parts[parts.length - 4]);
    const g = parseInt(parts[parts.length - 3]);
    const b = parseInt(parts[parts.length - 2]);
    const name = parts.slice(1, parts.length - 4).join(" ");
    colorList.push({ name, code, r, g, b });
  });
  return colorList;
}
function findClosestSherwinColor(colorList, r, g, b) {
  const targetLab = rgbToLab(r, g, b);
  let closest = null;
  let minDist = Infinity;
  colorList.forEach(c => {
    const lab = rgbToLab(c.r, c.g, c.b);
    const dist = ciede2000(targetLab, lab);
    if (dist < minDist) {
      minDist = dist;
      closest = c;
    }
  });
  return closest;
}

const fileInput = document.getElementById('fileInput');
const preview = document.getElementById('preview');
const container = document.getElementById('container');
const overlayCircle = document.getElementById('overlayCircle');
const colorBox = document.getElementById('colorBox');
const hexCode = document.getElementById('hexCode');
const sherwinName = document.getElementById('sherwinName');
const editButton = document.getElementById('editButton');

let sherwinColors = [];

fetch('allsherwincolours.txt')
  .then(res => res.text())
  .then(text => { sherwinColors = loadSherwinColors(text); });

fileInput.addEventListener('change', () => {
  if (!fileInput.files.length) return;
  const file = fileInput.files[0];
  const img = new Image();

  img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);

    const centerX = Math.floor(canvas.width / 2);
    const centerY = Math.floor(canvas.height / 2);
    const radius = 20;

    let rSum = 0, gSum = 0, bSum = 0, count = 0;
    const imageData = ctx.getImageData(centerX - radius, centerY - radius, radius * 2, radius * 2);
    const data = imageData.data;

    for (let y = 0; y < radius * 2; y++) {
      for (let x = 0; x < radius * 2; x++) {
        const dx = x - radius;
        const dy = y - radius;
        if (dx * dx + dy * dy <= radius * radius) {
          const idx = (y * radius * 2 + x) * 4;
          rSum += data[idx];
          gSum += data[idx + 1];
          bSum += data[idx + 2];
          count++;
        }
      }
    }

    const avgR = Math.round(rSum / count);
    const avgG = Math.round(gSum / count);
    const avgB = Math.round(bSum / count);

    const toHex = v => v.toString(16).padStart(2, '0');
    const avgHex = `#${toHex(avgR)}${toHex(avgG)}${toHex(avgB)}`;

    preview.src = img.src;
    container.style.display = 'inline-block';
    overlayCircle.style.display = 'block';
    colorBox.style.backgroundColor = avgHex;
    colorBox.style.display = 'block';
    hexCode.textContent = avgHex;
    hexCode.style.display = 'block';

    if (sherwinColors.length) {
      const closest = findClosestSherwinColor(sherwinColors, avgR, avgG, avgB);
      sherwinName.textContent = `${closest.code} ${closest.name}`;
      sherwinName.style.display = 'block';
    } else {
      sherwinName.style.display = 'none';
    }

    editButton.style.display = 'inline-block';
    editButton.onclick = () => {
      localStorage.setItem('pickedColor', avgHex);
      window.location.href = 'sherwin-project.html';
    };
  };
  img.src = URL.createObjectURL(file);
});
</script>

</body>
</html>
